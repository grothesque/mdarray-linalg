//! Simple function-based interface to linear algebra libraries

use std::mem::MaybeUninit;

use cblas_sys::{CBLAS_LAYOUT, CBLAS_TRANSPOSE, CBLAS_UPLO, CBLAS_SIDE, CBLAS_DIAG};
use mdarray::{DSlice, DTensor, Layout};
use num_complex::ComplexFloat;
use mdarray_linalg::{into_i32, dims2, dims3, trans_stride};

use super::scalar::BlasScalar;

{% for func, args in functions_simple.items() %}
pub fn {{ func }}<{%- for g in args[0].generics -%}{{ g }}{% if not loop.last %}, {% endif %}{%- endfor -%}> (
    {%- for name in args[0].name %}
    {{ name }}: {{ args[0].type[loop.index0] }}{% if not loop.last %}, {% endif %}
    {%- endfor %}
    ) where {%for i in range(args[0].generics | length) %} {{args[0].generics[i]}} : {{args[0].bounds[i]}},
  {%endfor %}{
    {# --- Extract and assert dimensions --- #}
    {%- set ns = namespace(nd=0) %}{%- for name in args[0].name %}{%- set t = args[0].type[loop.index0] %}{%- if "DSlice" in t %}{%- set ns.nd = ns.nd + 2 %}{%- endif %}{%- endfor %}{% if ns.nd == 6 %}
  let (m, n, k) = dims3(a.shape(), b.shape(), c.shape());
{% else %}
  let (m, n) = dims2(a.shape(), b.shape());
{% endif %}

{# --- Determine strides --- #}
{% if ns.nd == 6 %}
      let row_major = c.stride(1) == 1;
    assert!(row_major || c.stride(0) == 1, "c must be contiguous in one dimension");
{% else %}
      let row_major = b.stride(1) == 1;
    assert!(row_major || b.stride(0) == 1, "b must be contiguous in one dimension");
{% endif %}

    let (same_order, other_order) = if row_major {
        (CBLAS_TRANSPOSE::CblasNoTrans, CBLAS_TRANSPOSE::CblasTrans)
    } else {
        (CBLAS_TRANSPOSE::CblasTrans, CBLAS_TRANSPOSE::CblasNoTrans)
    };
    let (a_trans, a_stride) = trans_stride!(a, same_order, other_order);
    let (b_trans, b_stride) = trans_stride!(b, same_order, other_order);

{% if ns.nd == 6 %}
  let c_stride = into_i32(c.stride(if row_major { 0 } else { 1 } ));
{% else %}
    let b_stride = into_i32(b.stride(if row_major { 0 } else { 1 } ));
{% endif %}


    unsafe { T::cblas_{{ func }}(
    {% for arg in args[1] %}{% if 'RowMajor' in arg %}if row_major {
                CBLAS_LAYOUT::CblasRowMajor
            } else {
                CBLAS_LAYOUT::CblasColMajor
            }{%else%}{{arg}}{%endif%}{% if not loop.last %}, {% endif %}
  {% endfor %}  )
  }
}

pub fn {{ func }}_uninit<{%- for g in args[0].generics -%}{{ g }}{% if not loop.last %}, {% endif %}{%- endfor -%}>(
    {%- for name in args[0].name %}
    {%- set t = args[0].type[loop.index0] %}
    {%- if "&mut DSlice" in t %}
    mut {{ name }}: DTensor<MaybeUninit<T>, 2>{% if not loop.last %}, {% endif %}
    {%- else %}
    {{ name }}: {{ t }}{% if not loop.last %}, {% endif %}
    {%- endif %}
    {%- endfor %}
) -> DTensor<T, 2> where {%for i in range(args[0].generics | length) %} {{args[0].generics[i]}} : {{args[0].bounds[i]}},
  {%endfor %}{
    {# --- Extract and assert dimensions --- #}
    {%- set ns = namespace(nd=0) %}{%- for name in args[0].name %}{%- set t = args[0].type[loop.index0] %}{%- if "DSlice" in t %}{%- set ns.nd = ns.nd + 2 %}{%- endif %}{%- endfor %}{% if ns.nd == 6%}
  let (m, n, k) = dims3(a.shape(), b.shape(), c.shape());
{% else %}
  let (m, n) = dims2(a.shape(), b.shape());
{% endif %}
    {# --- Determine strides --- #}
{% if ns.nd == 6 %}
  debug_assert!(c.stride(1) == 1);
{% else %}
  debug_assert!(b.stride(1) == 1);
{% endif %}
    let same_order = CBLAS_TRANSPOSE::CblasNoTrans;
    let other_order = CBLAS_TRANSPOSE::CblasTrans;

    let (a_trans, a_stride) = trans_stride!(a, same_order, other_order);
    let (b_trans, b_stride) = trans_stride!(b, same_order, other_order);

{% if ns.nd == 6 %}
  let c_stride = into_i32(c.stride(0));
{% else %}
  let b_stride = into_i32(b.stride(0));
{% endif %}

   unsafe { T::cblas_{{ func }}(
{% for arg in args[1] %}    {{ arg }}{% if not loop.last %}, {% endif %}
{% endfor %}  );
{% if ns.nd == 6 %}
  c.assume_init()
{% else %}
  b.assume_init()
{% endif %}
}
    //  {{ func }}_uninit
}
{% endfor %}
